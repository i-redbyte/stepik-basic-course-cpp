#include <iostream>

/**В этой задаче вам нужно реализовать функцию,
 * которая сдвигает содержимое массива влево на заданное число позиций (циклический сдвиг).
 * На вход функция принимает массив, его размер и величину сдвига. Например, если на вход функции подан массив:
 * int a[] = { 1, 2, 3, 4, 5 }; и требуется циклически сдвинуть его влево на 2 позиции,
 * то на выходе мы получим числа в таком порядке: 3, 4, 5, 1, 2.
 * Обратите внимание, что величина сдвига может быть нулевой, а может быть и больше размера массива, все эти случаи нужно учесть.
 * Требования к реализации:
 * вам нужно реализовать только функцию циклического сдвига.
 * При этом она не должна вводить или выводить что-либо.
 * При решении этой задачи вы можете определять любые вспомогательные функции, если они вам нужны.
 * Реализовывать функцию main не нужно. Предполагается, что вам не потребуется дополнительная память,
 * а именно: массивы и стандартные контейнеры.
 * Пользоваться стандартными алгоритмами и контейнерами не разрешается, даже если вы с ними знакомы.
 * Рекомендация: перед тем, как начать кодировать решение этой задачи,
 * продумайте алгоритм, который вы будете использовать.
 * В данной задаче не проверяется эффективность этого алгоритма (в разумных пределах).
 * Подсказка: вам может потребоваться оператор % для вычисления остатка.
 * Наиболее простая реализация этой функции сдвигает массив на один элемент за проход.
 * Наиболее простая реализация несколько раз использует функцию, которая переставляет элементы массива в обратном порядке.*/

void swap(int *a, int *b) {
    int t = *a;
    *a = *b;
    *b = t;
}

void rotate(int a[], unsigned size, unsigned shift) {
    shift %= size;
    unsigned int n = size - 1;
    for (int i = 0; i < shift; ++i) {
        for (int j = 0; j < n; j++) {
            swap(&a[j], &a[j + 1]);
        }
    }
}

/**Очень часто для работы со строками нам нужно сначала вычислить длину строки.
 * Для C-style строк длина нигде явно не хранится, но её можно вычислить.
 * Напишите функцию, которая вычисляет длину C-style строки. Учтите, что завершающий нулевой символ считать не нужно.
 * Требования к реализации: при выполнении этого задания вы можете создавать любые вспомогательные функции.
 * Вводить или выводить что-либо не нужно. Реализовывать функцию main не нужно.*/

unsigned mystrlen(const char *str) {
    unsigned result = 0;
    while (*str++) ++result;
    return result;
}

/** Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк.
 * Функция конкатенации принимает на вход две C-style строки и дописывает вторую в конец первой так,
 * чтобы первая строка представляла из себя одну C-style строку равную конкатенации двух исходных.
 * Не забудьте, что в результирующей строке должен быть только один нулевой символ —
 * тот, что является маркером конца строки.
 * Гарантируется, что в первой строке достаточно памяти (т.е. она располагается в массиве достаточной длины),
 * чтобы разместить конкатенацию обеих строк, но не больше.
 * Требования к реализации:
 * при выполнении задания вы можете определять любые вспомогательные функции, если они вам нужны. */

void mystrcat(char *to, const char *from) {
    unsigned len = mystrlen(to);
    while (*from != '\0'){
        to[len] = *from;
        *from++;
        ++len;
    }
    to[len] ='\0';
}

int main() {

    int a[] = {1, 2, 3, 4, 5};

    rotate(a, 5, 2);
    std::cout << std::endl;
    for (int i: a) {
        std::cout << i << " ";
    }
    std::cout << std::endl;
    std::cout << mystrlen("I love C++") << std::endl;
    std::cout << mystrlen("12345") << std::endl;
    std::cout << mystrlen("12\0 345") << std::endl;
    char result[] = "";
    mystrcat(result, "C++");
    std::cout << result << std::endl;
    return 0;
}